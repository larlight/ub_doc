The data product classes are meant to store LArSoft output data, hence their design follows closely with what is in LArSoft.
If you look at a header file of data product class, you should find LArLite data product classes carry same or very similar attributes name to reduce confusion.
For adding further data product classes to store LArSoft data, it is recommended to keep this trend to reduce confusion.
Here is a list of LArLite data products (left) with corresponding LArSoft data product (right) as of now.
\begin{lstlisting}
    larlite::gtruth <==> simb::GTruth
    larlite::mcflux <==> simb::MCFlux
    larlite::mctruth <==> simb::MCTruth
    larlite::mcnu <==> simb::MCNeutrino
    larlite::mctrajectory <==> simb::MCTrajectory
    larlite::mcpart <==> simb::MCParticle
    larlite::mcshower <==> sim::MCTruth
    larlite::simch <==> sim::SimChannel
    larlite::rawdigit <==> raw::RawDigit
    larlite::wire <==> recob::Wire
    larlite::hit  <==> recob::Hit
    larlite::seed  <==> recob::Seed
    larlite::cluster <==> recob::Cluster
    larlite::spacepoint <==> recob::SpacePoint
    larlite::track <==> recob::Track
    larlite::shower <==> recob::Shower
    larlite::endpoint2d <==> recob::EndPoint2D
    larlite::vertex <==> recob::Vertex
    larlite::calorimetry <==> anab::Calorimetry
    larlite::partid <==> anab::ParticleID
    larlite::pfpart <==> recob::PFParticle
    larlite::user_info ... LArLite-only custom data product
\end{lstlisting}
There is additional data product called {\ttfamily user\_info} which will be described later.

All data product class shares the base class {\ttfamily larlite::data\_base} which stores only one variable: {\ttfamily larlite::data::DataType\_t}. This \enum value specifies the type of data stored. For instance, {\ttfamily larlite::hit} data product stores a type {\ttfamily larlite::data::kHit}.

\subsection{What is stored per event?}
Despite a few exceptions (which I describe next), each data product class {\ttfamily T} has a corresponding collection class which inherits from {\ttfamily std::vector<T>}, named as {\ttfamily event\_T}. 
For instance, in {\ttfamily cluster.hh}, you find there is a class {\ttfamily larlite::cluster} and {\ttfamily larlite::event\_cluster} where the latter is a type {\ttfamily std::vector<larlite::cluster>}. What is stored per event is {\ttfamily std::vector<T>}, just like a collection of object is stored in LArSoft. This collection data product also inherits from {\ttfamily event\_base} which carries additional inforamtion:
\begin{itemize}
\item {\ttfamily unsigned int} Event number
\item {\ttfamily unsigned int} Run number
\item {\ttfamily unsigned int} Sub-Run number
\item {\ttfamily std::string} Producer's name
\item {\ttfamily std::map<larlite::product\_id,AssSet\_t>} Association information
\end{itemize}
Just like everything else, {\ttfamily event\_base} inherits from {\ttfamily data\_base} and hence knows its own data product type. Together with the producer's name string, this forms a unique data product identification in LArLite. For instance, type {\ttfamily larlite::data::kHit} made by ``gaushit'' is a specific data product ID. {\ttfamily larlite::product\_id} is a class defined under {\ttfamily core/DataFormat/larlite\_dataformat\_utils.h}, and is simply {\ttfamily std::pair<larlite::data::DataType\_t,std::string>} to hold such data product identity. 

As you noticed, the last bullet point above is the associlation information holder.
It is a {\ttfamily std::map} with a key that identifies an associated data product ID, and the value holds the corresponding association information.
See Sec.\ref{chap:dataformat:association} for details of association information.

\subsubsection{Data Products Exception to {\ttfamily event\_T}}
Exceptions to this event-wise collection storage scheme include {\ttfamily larlite::mcnu} and {\ttfamily larlite::mctrajectory}.
In LArSoft, {\ttfamily simb::MCNeutrino} is stored as a part of {\ttfamily simb::MCTruth}. Likewise, {\ttfamily simb::MCTrajectory} is stored as a part of {\ttfamily simb::MCParticle}. LArLite respects this scheme and stores {\ttfamily larlite::mcnu} in {\ttfamily larlite::mctruth} and {\ttfamily larlite::mctrajectory} in {\ttfamily larlite::mcpart}.

\subsubsection{A few remarks on MC data products}
In case you are unfamiliar with these MC information, though this is a side-track, {\ttfamily larlite::mcnu} stores neutrino specific information from neutrino generator. It is a part of {\ttfamily larlite::mctruth} because a generator (whether it is neutrino generator or not) stores {\ttfamily larlite::mctruth} in general. Similarly, {\ttfamily larlite::mctrajectory} is part of {\ttfamily larlite::mcpart} because a particle's trajectory points (that is what {\ttfamily larlite::mctrajectory} is) belong to a particle information which is {\ttfamily larlite::mcpart}.

\subsubsection{More useful info to store?}
If you have some information you think is very useful, let's store it :)
For instance, it was advised that knowing a part of {\ttfamily larlite::mctrajectory} that is inside the fiducial volume is very useful information.
So we added this information in {\ttfamily larlite::mctrajectory} for users so that a user can access particle trajectory points inside the fiducial volume quickly instead of looping over all trajectory points and inspect whether it is in the fiducial volume or not.

Your ideas can help others. So please share it!

\subsubsection{Adding new data product?}
By all means, go ahead. There are important pieces missing, for instance vertex!
That being said, however, a mistake can break DataFormat which is shared among all users.
So feel free to consult with the author.\\

Alternative solution is to ask the author to add it. 
Believe me, it's so simple and it won't take me > 10 minutes to add another on the list above.

\subsection{Custom data product for dynamic variable declaration ... {\ttfamily user\_info}}

Sometimes you want a custom data product and store information in the output data root file.
For instance:
\begin{itemize}
\item you want to store some parameter values but not worth making a new data product (say studying a parameter)
\item you want to store some parameter values for certain events/objects, but not all.
\end{itemize}

Then {\ttfamily user\_info} might be handy for you. This data product class contains several {\ttfamily std::map} which allows you to store following basic variable types:
\begin{lstlisting}
    Bool_t
    Int_t
    Double_t
    std::string
    std::vector<Bool_t>
    std::vector<Int_t>
    std::vector<Double_t>
    std::vector<std::string>
\end{lstlisting}
When you store these variables in {\ttfamily user\_info}, you store with a {\ttfamily std::string} key. 
Then you can access the stored value by this key. 
You can use the same key to store different type of variables: mixing is prevented.
If you reuse a key that is already used to store the same type of variable, you will overwrite the value.
There is a function to check if the key is already in use or not, so a user can avoid overwriting the value.\\

Using {\ttfamily std::map} is not great for speed when retrieving the variable. 
But this seems to be a matter of micro-seconds or less, depending on number of keys used.

\subsection{Association}
\label{chap:dataformat:association}
The author has little idea about how exactly association is stored in \ART. But that does not matter.

As you have seen in the previous section, all data product are stored in terms of {\ttfamily std::vector} collection.
So ultimately what you need to associate one object to (an)other are:
\begin{itemize}
\item Associated data product ID
\item A set of indexes that point to the right {\ttfamily std::vector} index.
\end{itemize}
As mentioned earlier, {\ttfamily event\_base} class holds association information
\begin{lstlisting}
    std::map<larlite::product_id,larlite::AssSet_t>
\end{lstlisting}
where 
\begin{lstlisting}
larlite::AssSet_t
larlite::product_id
\end{lstlisting}
are simply
\begin{lstlisting}
std::vector<std::vector<unsigned int>>
std::pair<larlite::data::DataType_t,std::string>
\end{lstlisting}
in respective order. As you might guess, the key is the product ID of associated data container, and the value is the association information. 

The association information needs to link a) a location of subject data product and b) locations of associated data products.
In case it is confusing, a) is the index of {\ttfamily event\_T} which holds this association information.
b) is a set of indices that concerns associated data products, say {\ttfamily event\_U}.

For this reason, the association information is a two-layered vector: the outer (primary) vector index points to one (origin) data product, and the inner vector indecies point to associated data product indices. 

Retrieving association is as simple as calling the following function:
\begin{lstlisting}
    event_base::association(larlite::product_id)
\end{lstlisting}
You provide the product ID of association as an argument.

For instance, here's a code snipset to loop over associated hits for clusters to calculate charge sum per cluster and fill a histogram.
\begin{lstlisting}
    auto ass_info = ev_cluster.association(ev_hit.product_id());
    double cluster_q=0;
    for(auto const& hit_indices : ass_info) {
      cluster_q = 0;
      for(auto const& hit_index : hit_indices)
        cluster_q += ev_hit[hit_index].Charge();
      h->Fill(cluster_q);
    }
\end{lstlisting}
where {\ttfamily ev\_cluster} and {\ttfamily ev\_hit} are both variable names of {\ttfamily event\_cluster} and {\ttfamily event\_hit} data product class instances. 
